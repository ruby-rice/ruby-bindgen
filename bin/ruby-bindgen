#! /usr/bin/env ruby

# To make testing/debugging easier test within this source tree versus an installed gem
require 'bundler/setup'

require 'yaml'

module RubyBindGen
  class Cmd
    attr_accessor :config

    def initialize
      parse_args
      load_config
      setup_libclang
      require 'ruby-bindgen'
      validate_config
    end

    def parse_args
      if ARGV.empty? || ARGV[0] == '-h' || ARGV[0] == '--help'
        puts usage
        exit(ARGV.empty? ? 1 : 0)
      end

      @config_path = ARGV[0]

      unless File.exist?(@config_path)
        raise "Config file not found: #{@config_path}"
      end
    end

    def usage
      <<~USAGE
        ruby-bindgen

        Usage: ruby-bindgen <config.yaml>

        Generates Ruby bindings for C and C++ libraries using a YAML configuration file.

        See documentation for config file format: https://github.com/user/ruby-bindgen/docs/configuration.md

        Options:
          -h, --help    Show this help message
      USAGE
    end

    def load_config
      @config = YAML.safe_load(File.read(@config_path), permitted_classes: [], permitted_symbols: [], aliases: true)
      @config = symbolize_keys(@config)
      @config_dir = File.dirname(File.expand_path(@config_path))

      # Select toolchain: clang-cl for MSVC (mswin), clang for everything else
      @toolchain = RUBY_PLATFORM =~ /mswin/ ? :'clang-cl' : :clang

      # New structure: clang-cl:/clang: as top-level keys with libclang and args
      if @config[@toolchain].is_a?(Hash)
        toolchain_config = @config[@toolchain]
        @config[:libclang] = toolchain_config[:libclang]
        @config[:clang_args] = toolchain_config[:args]
      else
        # Legacy structure: separate libclang: and clang_args: with nested toolchain keys
        if @config[:libclang].is_a?(Hash)
          @config[:libclang] = @config[:libclang][@toolchain]
        end

        if @config[:clang_args].is_a?(Hash)
          @config[:clang_args] = @config[:clang_args][@toolchain]
        end
      end

      # Resolve relative paths for input/output (relative to config file location)
      @config[:input] = resolve_path(@config[:input]) if @config[:input]
      @config[:output] = resolve_path(@config[:output]) if @config[:output]
    end

    def resolve_path(path)
      return path if Pathname.new(path).absolute?
      File.expand_path(path, @config_dir)
    end

    def setup_libclang
      if @config[:libclang]
        ENV['LIBCLANG'] = @config[:libclang]
      end
    end

    def symbolize_keys(hash)
      hash.transform_keys(&:to_sym).transform_values do |value|
        case value
        when Hash then symbolize_keys(value)
        else value
        end
      end
    end

    def validate_config
      raise "Config must specify 'input'" unless @config[:input]
      raise "Config must specify 'output'" unless @config[:output]
      raise "Config must specify 'format'" unless @config[:format]

      unless File.directory?(@config[:input])
        raise "Input path must be a directory: #{@config[:input]}"
      end

      unless File.directory?(@config[:output])
        raise "Output path must be a directory: #{@config[:output]}"
      end

      unless %w[FFI Rice].include?(@config[:format])
        raise "Format must be 'FFI' or 'Rice', got: #{@config[:format]}"
      end

      # Validate extension name is a valid C/C++ identifier (if provided)
      if @config[:extension] && !@config[:extension].match?(/\A[A-Za-z_][A-Za-z0-9_]*\z/)
        raise "Extension name must be a valid C/C++ identifier: #{@config[:extension]}"
      end
    end

    def run
      match_patterns = @config[:match] || ["**/*.{h,hpp}"]
      skip_patterns = @config[:skip] || []
      clang_args = @config[:clang_args] || []
      skip_symbols = @config[:skip_symbols] || []
      export_macros = @config[:export_macros] || []

      inputter = RubyBindgen::Inputter.new(@config[:input], match_patterns, skip_patterns)
      parser = RubyBindgen::Parser.new(inputter, clang_args)
      outputter = RubyBindgen::Outputter.new(@config[:output])

      format_klass = RubyBindgen::Visitors.const_get(@config[:format])
      format = format_klass.new(outputter, @config[:extension],
                                skip_symbols: skip_symbols,
                                export_macros: export_macros,
                                include_header: @config[:include])
      parser.generate(format)
    end
  end
end

begin
  cmd = RubyBindGen::Cmd.new
  cmd.run
rescue => e
  STDERR.puts "Error: #{e.message}"
  exit 1
end
