#! /usr/bin/env ruby

# To make testing/debugging easier test within this source tree versus an installed gem
require 'bundler/setup'

require 'ruby-bindgen'
require 'yaml'

module RubyBindGen
  class Cmd
    attr_accessor :config

    def initialize
      parse_args
      load_config
      validate_config
    end

    def parse_args
      if ARGV.empty? || ARGV[0] == '-h' || ARGV[0] == '--help'
        puts usage
        exit(ARGV.empty? ? 1 : 0)
      end

      @config_path = ARGV[0]

      unless File.exist?(@config_path)
        raise "Config file not found: #{@config_path}"
      end
    end

    def usage
      <<~USAGE
        ruby-bindgen #{RubyBindgen::VERSION}

        Usage: ruby-bindgen <config.yaml>

        Generates Ruby bindings for C and C++ libraries using a YAML configuration file.

        See documentation for config file format: https://github.com/user/ruby-bindgen/docs/configuration.md

        Options:
          -h, --help    Show this help message
      USAGE
    end

    def load_config
      @config = YAML.safe_load(File.read(@config_path), permitted_classes: [], permitted_symbols: [], aliases: true)
      @config = symbolize_keys(@config)
    end

    def symbolize_keys(hash)
      hash.transform_keys(&:to_sym).transform_values do |value|
        case value
        when Hash then symbolize_keys(value)
        else value
        end
      end
    end

    def validate_config
      raise "Config must specify 'extension'" unless @config[:extension]
      raise "Config must specify 'input'" unless @config[:input]
      raise "Config must specify 'output'" unless @config[:output]
      raise "Config must specify 'format'" unless @config[:format]

      unless File.directory?(@config[:input])
        raise "Input path must be a directory: #{@config[:input]}"
      end

      unless File.directory?(@config[:output])
        raise "Output path must be a directory: #{@config[:output]}"
      end

      unless %w[FFI Rice].include?(@config[:format])
        raise "Format must be 'FFI' or 'Rice', got: #{@config[:format]}"
      end

      # Validate extension name is a valid C/C++ identifier
      unless @config[:extension].match?(/\A[A-Za-z_][A-Za-z0-9_]*\z/)
        raise "Extension name must be a valid C/C++ identifier: #{@config[:extension]}"
      end
    end

    def run
      match_pattern = @config[:match]&.first || "**/*.{h,hpp}"
      skip_patterns = @config[:skip] || []
      clang_args = @config[:clang_args] || []
      skip_symbols = @config[:skip_symbols] || []
      export_macros = @config[:export_macros] || []

      inputter = RubyBindgen::Inputter.new(@config[:input], match_pattern, skip_patterns)
      parser = RubyBindgen::Parser.new(inputter, clang_args)
      outputter = RubyBindgen::Outputter.new(@config[:output])

      format_klass = RubyBindgen::Visitors.const_get(@config[:format])
      format = format_klass.new(outputter, @config[:extension],
                                skip_symbols: skip_symbols,
                                export_macros: export_macros)
      parser.generate(format)
    end
  end
end

begin
  cmd = RubyBindGen::Cmd.new
  cmd.run
rescue => e
  STDERR.puts "Error: #{e.message}"
  exit 1
end
